// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "research_checker.proto" (package "research_checker", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message research_checker.CheckRequest
 */
export interface CheckRequest {
    /**
     * @generated from protobuf field: string url = 1;
     */
    url: string;
}
/**
 * @generated from protobuf message research_checker.CheckResponse
 */
export interface CheckResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated research_checker.CheckAuthor authors = 2;
     */
    authors: CheckAuthor[];
    /**
     * @generated from protobuf field: repeated research_checker.CheckAffiliation affiliations = 3;
     */
    affiliations: CheckAffiliation[];
    /**
     * @generated from protobuf field: repeated research_checker.CheckCitation citations = 4;
     */
    citations: CheckCitation[];
    /**
     * @generated from protobuf field: repeated research_checker.CheckFunding fundings = 5;
     */
    fundings: CheckFunding[];
    /**
     * @generated from protobuf field: research_checker.CheckPubBase pub_base = 6;
     */
    pubBase?: CheckPubBase;
    /**
     * @generated from protobuf field: string doi = 7;
     */
    doi: string;
    /**
     * @generated from protobuf field: optional string pubmed_id = 8;
     */
    pubmedId?: string;
}
/**
 * @generated from protobuf message research_checker.CheckAuthor
 */
export interface CheckAuthor {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: repeated research_checker.RetractedArticle retracted_articles = 3;
     */
    retractedArticles: RetractedArticle[];
}
/**
 * @generated from protobuf message research_checker.CheckAffiliation
 */
export interface CheckAffiliation {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated research_checker.RetractedArticle retracted_articles = 2;
     */
    retractedArticles: RetractedArticle[];
}
/**
 * @generated from protobuf message research_checker.CheckCitation
 */
export interface CheckCitation {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string doi = 2;
     */
    doi: string;
    /**
     * @generated from protobuf field: optional string pubmed_id = 3;
     */
    pubmedId?: string;
    /**
     * @generated from protobuf field: bool retracted = 4;
     */
    retracted: boolean;
}
/**
 * @generated from protobuf message research_checker.CheckFunding
 */
export interface CheckFunding {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated research_checker.RetractedArticle retracted_articles = 2;
     */
    retractedArticles: RetractedArticle[];
}
/**
 * @generated from protobuf message research_checker.CheckPubBase
 */
export interface CheckPubBase {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated research_checker.RetractedArticle retracted_articles = 2;
     */
    retractedArticles: RetractedArticle[];
}
/**
 * @generated from protobuf message research_checker.RetractedArticle
 */
export interface RetractedArticle {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string doi = 2;
     */
    doi: string;
    /**
     * @generated from protobuf field: optional string pubmed_id = 3;
     */
    pubmedId?: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class CheckRequest$Type extends MessageType<CheckRequest> {
    constructor() {
        super("research_checker.CheckRequest", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CheckRequest>): CheckRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        if (value !== undefined)
            reflectionMergePartial<CheckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckRequest): CheckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message research_checker.CheckRequest
 */
export const CheckRequest = new CheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckResponse$Type extends MessageType<CheckResponse> {
    constructor() {
        super("research_checker.CheckResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "authors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CheckAuthor },
            { no: 3, name: "affiliations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CheckAffiliation },
            { no: 4, name: "citations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CheckCitation },
            { no: 5, name: "fundings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CheckFunding },
            { no: 6, name: "pub_base", kind: "message", T: () => CheckPubBase },
            { no: 7, name: "doi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "pubmed_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CheckResponse>): CheckResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.authors = [];
        message.affiliations = [];
        message.citations = [];
        message.fundings = [];
        message.doi = "";
        if (value !== undefined)
            reflectionMergePartial<CheckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckResponse): CheckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated research_checker.CheckAuthor authors */ 2:
                    message.authors.push(CheckAuthor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated research_checker.CheckAffiliation affiliations */ 3:
                    message.affiliations.push(CheckAffiliation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated research_checker.CheckCitation citations */ 4:
                    message.citations.push(CheckCitation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated research_checker.CheckFunding fundings */ 5:
                    message.fundings.push(CheckFunding.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* research_checker.CheckPubBase pub_base */ 6:
                    message.pubBase = CheckPubBase.internalBinaryRead(reader, reader.uint32(), options, message.pubBase);
                    break;
                case /* string doi */ 7:
                    message.doi = reader.string();
                    break;
                case /* optional string pubmed_id */ 8:
                    message.pubmedId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated research_checker.CheckAuthor authors = 2; */
        for (let i = 0; i < message.authors.length; i++)
            CheckAuthor.internalBinaryWrite(message.authors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated research_checker.CheckAffiliation affiliations = 3; */
        for (let i = 0; i < message.affiliations.length; i++)
            CheckAffiliation.internalBinaryWrite(message.affiliations[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated research_checker.CheckCitation citations = 4; */
        for (let i = 0; i < message.citations.length; i++)
            CheckCitation.internalBinaryWrite(message.citations[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated research_checker.CheckFunding fundings = 5; */
        for (let i = 0; i < message.fundings.length; i++)
            CheckFunding.internalBinaryWrite(message.fundings[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* research_checker.CheckPubBase pub_base = 6; */
        if (message.pubBase)
            CheckPubBase.internalBinaryWrite(message.pubBase, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string doi = 7; */
        if (message.doi !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.doi);
        /* optional string pubmed_id = 8; */
        if (message.pubmedId !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.pubmedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message research_checker.CheckResponse
 */
export const CheckResponse = new CheckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckAuthor$Type extends MessageType<CheckAuthor> {
    constructor() {
        super("research_checker.CheckAuthor", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "retracted_articles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RetractedArticle }
        ]);
    }
    create(value?: PartialMessage<CheckAuthor>): CheckAuthor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.id = "";
        message.retractedArticles = [];
        if (value !== undefined)
            reflectionMergePartial<CheckAuthor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckAuthor): CheckAuthor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* repeated research_checker.RetractedArticle retracted_articles */ 3:
                    message.retractedArticles.push(RetractedArticle.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckAuthor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* repeated research_checker.RetractedArticle retracted_articles = 3; */
        for (let i = 0; i < message.retractedArticles.length; i++)
            RetractedArticle.internalBinaryWrite(message.retractedArticles[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message research_checker.CheckAuthor
 */
export const CheckAuthor = new CheckAuthor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckAffiliation$Type extends MessageType<CheckAffiliation> {
    constructor() {
        super("research_checker.CheckAffiliation", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "retracted_articles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RetractedArticle }
        ]);
    }
    create(value?: PartialMessage<CheckAffiliation>): CheckAffiliation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.retractedArticles = [];
        if (value !== undefined)
            reflectionMergePartial<CheckAffiliation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckAffiliation): CheckAffiliation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated research_checker.RetractedArticle retracted_articles */ 2:
                    message.retractedArticles.push(RetractedArticle.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckAffiliation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated research_checker.RetractedArticle retracted_articles = 2; */
        for (let i = 0; i < message.retractedArticles.length; i++)
            RetractedArticle.internalBinaryWrite(message.retractedArticles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message research_checker.CheckAffiliation
 */
export const CheckAffiliation = new CheckAffiliation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckCitation$Type extends MessageType<CheckCitation> {
    constructor() {
        super("research_checker.CheckCitation", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "doi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pubmed_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "retracted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CheckCitation>): CheckCitation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.doi = "";
        message.retracted = false;
        if (value !== undefined)
            reflectionMergePartial<CheckCitation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckCitation): CheckCitation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string doi */ 2:
                    message.doi = reader.string();
                    break;
                case /* optional string pubmed_id */ 3:
                    message.pubmedId = reader.string();
                    break;
                case /* bool retracted */ 4:
                    message.retracted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckCitation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string doi = 2; */
        if (message.doi !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.doi);
        /* optional string pubmed_id = 3; */
        if (message.pubmedId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.pubmedId);
        /* bool retracted = 4; */
        if (message.retracted !== false)
            writer.tag(4, WireType.Varint).bool(message.retracted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message research_checker.CheckCitation
 */
export const CheckCitation = new CheckCitation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckFunding$Type extends MessageType<CheckFunding> {
    constructor() {
        super("research_checker.CheckFunding", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "retracted_articles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RetractedArticle }
        ]);
    }
    create(value?: PartialMessage<CheckFunding>): CheckFunding {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.retractedArticles = [];
        if (value !== undefined)
            reflectionMergePartial<CheckFunding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckFunding): CheckFunding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated research_checker.RetractedArticle retracted_articles */ 2:
                    message.retractedArticles.push(RetractedArticle.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckFunding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated research_checker.RetractedArticle retracted_articles = 2; */
        for (let i = 0; i < message.retractedArticles.length; i++)
            RetractedArticle.internalBinaryWrite(message.retractedArticles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message research_checker.CheckFunding
 */
export const CheckFunding = new CheckFunding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPubBase$Type extends MessageType<CheckPubBase> {
    constructor() {
        super("research_checker.CheckPubBase", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "retracted_articles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RetractedArticle }
        ]);
    }
    create(value?: PartialMessage<CheckPubBase>): CheckPubBase {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.retractedArticles = [];
        if (value !== undefined)
            reflectionMergePartial<CheckPubBase>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckPubBase): CheckPubBase {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated research_checker.RetractedArticle retracted_articles */ 2:
                    message.retractedArticles.push(RetractedArticle.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckPubBase, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated research_checker.RetractedArticle retracted_articles = 2; */
        for (let i = 0; i < message.retractedArticles.length; i++)
            RetractedArticle.internalBinaryWrite(message.retractedArticles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message research_checker.CheckPubBase
 */
export const CheckPubBase = new CheckPubBase$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetractedArticle$Type extends MessageType<RetractedArticle> {
    constructor() {
        super("research_checker.RetractedArticle", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "doi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pubmed_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RetractedArticle>): RetractedArticle {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.doi = "";
        if (value !== undefined)
            reflectionMergePartial<RetractedArticle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetractedArticle): RetractedArticle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string doi */ 2:
                    message.doi = reader.string();
                    break;
                case /* optional string pubmed_id */ 3:
                    message.pubmedId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetractedArticle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string doi = 2; */
        if (message.doi !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.doi);
        /* optional string pubmed_id = 3; */
        if (message.pubmedId !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.pubmedId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message research_checker.RetractedArticle
 */
export const RetractedArticle = new RetractedArticle$Type();
/**
 * @generated ServiceType for protobuf service research_checker.ResearchCheckerService
 */
export const ResearchCheckerService = new ServiceType("research_checker.ResearchCheckerService", [
    { name: "Check", options: {}, I: CheckRequest, O: CheckResponse }
]);
